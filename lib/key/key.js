/*
    mitum-js-util SDK for mitum-currency and mitum-data-blocksign
    Copyright (C) 2022 ProtoconNet

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
*/

/* SDK module */
const { BaseKey } = require('./base');
const { _hint, parseTyped, concatObjectsToBuffer, sum256, BigInteger } = require('../util');
const { MC_KEY, MC_KEYS, MC_ADDRESS } = require('../hint');

/* base58 package */
const bs58 = require('bs58');

const compare = (x, y) => {
    return Buffer.compare(x.key._buffer(), y.key._buffer());
};


class Key {

    constructor(key, w) {
        this.hint = _hint(MC_KEY);
        this.key = new BaseKey(key, 'unknown');
        this.weight = new BigInteger(w.toString());
    }

    buffer() {
        return Buffer.concat(
            [this.key.buffer(), this.weight.buffer()]
        );
    }

    dict() {
        const key = {};
        key._hint = this.hint;
        key.weight = this.weight.value;
        key.key = this.key.typed();
        return key;
    }
};


class Keys {

    constructor(keys, threshold) {
        this.hint = _hint(MC_KEYS);
        this.keys = keys;
        this.threshold = new BigInteger(threshold.toString());
        this.hash = this._generateHash();
    }

    /**
     * @returns {string} Address generated by keys, and threshold
     */
    get address() {
        return bs58.encode(this.hash) + MC_ADDRESS;
    }

    buffer() {
        const kArr = [];
        for (var i = 0; i < this.keys.length; i++) {
            kArr.push(this.keys[i]);
        }
        const sortedKeys = kArr.sort(compare);
        const bKeys = concatObjectsToBuffer(sortedKeys)

        const bThreshold = this.threshold.buffer();

        return Buffer.concat([bKeys, bThreshold]);
    }

    dict() {
        const keys = {};
        keys._hint = this.hint;
        keys.hash = bs58.encode(this.hash);

        const _keys = [];
        for (var i = 0; i < this.keys.length; i++) {
            _keys.push(
                this.keys[i].dict()
            );
        }
        keys.keys = _keys;
        keys.threshold = this.threshold.value;

        return keys;
    }

    _generateHash() {
        return sum256(this.buffer());
    }
};


class Address {

    constructor(addr) {
        let parsed = parseTyped(addr);

        this.type = parsed.type;
        this.addr = parsed.raw;

        if (this.type !== MC_ADDRESS) {
            throw '[ERROR] Invalid typed address for Address';
        }
    }

    buffer() {
        return Buffer.from(this.typed());
    }

    typed() {
        return this.addr + this.type;
    }
};


module.exports = {
    Key,
    Keys,
    Address
};